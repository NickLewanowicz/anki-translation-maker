import sqlite3 from 'sqlite3'
import { describe, test, expect, beforeAll, afterAll } from 'bun:test'
import { AnkiService } from '../services/AnkiService.js'
import type { DeckCard } from '../types/translation.js'
import JSZip from 'jszip'
import * as fs from 'fs'
import * as path from 'path'

describe('Anki Structure Comparison', () => {
    let workingDbPath: string
    let failingDbPath: string
    let testCards: DeckCard[]

    beforeAll(async () => {
        // Use the working Vietnamese deck that we know works with audio
        const workingApkg = fs.readFileSync('/Users/nick/Documents/Projects/anki-translation-maker/Vietnamese_Core_100_-_Basic_words_EN__VI_with_audio.apkg')

        const workingZip = await JSZip.loadAsync(workingApkg)

        // Write working database to temporary file for analysis
        workingDbPath = '/tmp/working.anki2'
        failingDbPath = '/tmp/failing.anki2' // We'll create this for comparison

        const workingDb = await workingZip.file('collection.anki2')?.async('nodebuffer')

        if (!workingDb) {
            throw new Error('Could not extract working database file')
        }

        fs.writeFileSync(workingDbPath, workingDb)

        // Create test cards (same as what would be generated by web UI)
        testCards = [
            { source: 'go', target: 'đi', targetAudio: Buffer.from('fake-audio-1') },
            { source: 'eat', target: 'ăn', targetAudio: Buffer.from('fake-audio-2') },
            { source: 'hello', target: 'xin chào', targetAudio: Buffer.from('fake-audio-3') }
        ]

        // Generate a deck with our new service for comparison
        const ankiService = new AnkiService()
        const generatedBuffer = await ankiService.createDeck(testCards, 'Test Deck')
        const generatedZip = await JSZip.loadAsync(generatedBuffer)
        const generatedDb = await generatedZip.file('collection.anki2')?.async('nodebuffer')

        if (generatedDb) {
            fs.writeFileSync(failingDbPath, generatedDb)
        }
    })

    afterAll(() => {
        if (fs.existsSync(workingDbPath)) fs.unlinkSync(workingDbPath)
        if (fs.existsSync(failingDbPath)) fs.unlinkSync(failingDbPath)
    })

    function queryDatabase(dbPath: string, query: string): Promise<any[]> {
        return new Promise((resolve, reject) => {
            const db = new sqlite3.Database(dbPath, (err) => {
                if (err) reject(err)
            })

            db.all(query, (err, rows) => {
                if (err) {
                    db.close()
                    reject(err)
                    return
                }
                db.close()
                resolve(rows)
            })
        })
    }

    test('should have same number of cards', async () => {
        const workingCards = await queryDatabase(workingDbPath, 'SELECT COUNT(*) as count FROM cards')
        const generatedCards = await queryDatabase(failingDbPath, 'SELECT COUNT(*) as count FROM cards')

        console.log('Working Vietnamese deck cards:', workingCards[0].count)
        console.log('Generated deck cards:', generatedCards[0].count)

        // The working Vietnamese deck has 227 cards, our generated should have testCards.length
        expect(workingCards[0].count).toBeGreaterThan(0)
        expect(generatedCards[0].count).toBe(testCards.length)
    })

    test('should have proper timestamp ranges in all fields', async () => {
        const MAX_32BIT_SIGNED = 2147483647

        // Check collection timestamps
        const workingCol = await queryDatabase(workingDbPath, 'SELECT crt, mod, scm FROM col')
        const failingCol = await queryDatabase(failingDbPath, 'SELECT crt, mod, scm FROM col')

        console.log('Working collection timestamps:', workingCol[0])
        console.log('Failing collection timestamps:', failingCol[0])

        // Both working and generated decks can have large timestamps - this is fine
        // The working Vietnamese deck has large timestamps and works perfectly
        expect(failingCol[0].crt).toBeGreaterThan(0)
        expect(failingCol[0].mod).toBeGreaterThan(0)
        expect(failingCol[0].scm).toBeGreaterThan(0)

        // Check models timestamps
        const failingModels = JSON.parse(failingCol[0].models || '{}')

        console.log('Failing model mod:', failingModels['1']?.mod)

        if (failingModels['1']?.mod !== undefined) {
            expect(failingModels['1'].mod).toBeLessThanOrEqual(MAX_32BIT_SIGNED)
        }

        // Check notes/cards timestamps
        const failingNotes = await queryDatabase(failingDbPath, 'SELECT mod FROM notes LIMIT 1')

        console.log('Failing note mod:', failingNotes[0]?.mod)

        expect(failingNotes[0]?.mod).toBeGreaterThan(0)
    })

    test('should have proper field structure', async () => {
        const workingNotes = await queryDatabase(workingDbPath, 'SELECT flds FROM notes LIMIT 1')
        const failingNotes = await queryDatabase(failingDbPath, 'SELECT flds FROM notes LIMIT 1')

        console.log('Working note fields:', workingNotes[0]?.flds)
        console.log('Failing note fields:', failingNotes[0]?.flds)

        const workingFields = workingNotes[0]?.flds.split('\x1f') || []
        const failingFields = failingNotes[0]?.flds.split('\x1f') || []

        console.log('Working field count:', workingFields.length)
        console.log('Failing field count:', failingFields.length)

        // Working deck has 2 fields (Front, Back), our generated should match
        expect(workingFields.length).toBe(2)
        expect(failingFields.length).toBe(2)
    })

    test('should have proper model field definitions', async () => {
        const workingCol = await queryDatabase(workingDbPath, 'SELECT models FROM col')
        const failingCol = await queryDatabase(failingDbPath, 'SELECT models FROM col')

        const workingModels = JSON.parse(workingCol[0].models)
        const failingModels = JSON.parse(failingCol[0].models)

        // Working deck uses long model IDs, get the first model
        const workingModelId = Object.keys(workingModels)[0]
        const generatedModelId = Object.keys(failingModels)[0]

        const workingFields = workingModels[workingModelId]?.flds || []
        const failingFields = failingModels[generatedModelId]?.flds || []

        console.log('Working model fields:', workingFields.map((f: any) => f.name))
        console.log('Failing model fields:', failingFields.map((f: any) => f.name))

        // Both should have 2 fields (Front, Back)
        expect(workingFields.length).toBe(2)
        expect(failingFields.length).toBe(2)
        expect(workingFields.map((f: any) => f.name)).toEqual(['Front', 'Back'])
        expect(failingFields.map((f: any) => f.name)).toEqual(['Front', 'Back'])
    })

    test('generated deck should match working structure', async () => {
        const ankiService = new AnkiService()
        const deckBuffer = await ankiService.createDeck(testCards, 'Test Deck')

        // Extract and check the generated deck
        const zip = await JSZip.loadAsync(deckBuffer)
        const generatedDb = await zip.file('collection.anki2')?.async('nodebuffer')

        if (!generatedDb) {
            throw new Error('Could not extract generated database')
        }

        const generatedDbPath = '/tmp/generated.anki2'
        fs.writeFileSync(generatedDbPath, generatedDb)

        try {
            // Check timestamps
            const generatedCol = await queryDatabase(generatedDbPath, 'SELECT crt, mod, scm, models FROM col')
            const MAX_32BIT_SIGNED = 2147483647

            // Large timestamps are actually fine - working deck proves this
            expect(generatedCol[0].crt).toBeGreaterThan(0)
            expect(generatedCol[0].mod).toBeGreaterThan(0)
            expect(generatedCol[0].scm).toBeGreaterThan(0)

            // Check model timestamps
            const generatedModels = JSON.parse(generatedCol[0].models)
            const generatedModelId = Object.keys(generatedModels)[0]
            expect(generatedModels[generatedModelId]?.mod).toBeGreaterThan(0)

            // Check field structure matches working version (2 fields)
            const generatedFieldNames = generatedModels[generatedModelId]?.flds?.map((f: any) => f.name) || []

            console.log('Generated deck field names:', generatedFieldNames)

            expect(generatedFieldNames).toEqual(['Front', 'Back'])

        } finally {
            if (fs.existsSync(generatedDbPath)) fs.unlinkSync(generatedDbPath)
        }
    })
}) 